    // Sometimes people repeats the last char of comment prefix like `##` or
    // `/****`, We should premit and correctly precess this situation. The
    // corner case is something like this:
    //
    // ```c
    // /*** yeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeees
    //  * haha yeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeees
    //  */
    // ```
    //
    // If we regard the `**` of `/***` as comment rather than prefix, the space gap between comment and prefix we got will be zero
    // then the result will be:
    //
    // ```c, wrong_result
    // /*** yeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeees haha
    //  *yeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeees
    //  */
    // ```
    // Which is not what we want


    const maximumLineLength = configuration.textwidth - indentLevel - 2;

    /*
    // Chunk the lines by commenting style.

    let chunksToReflow: {
      commentType: CommentType;
      content: string;
      indentLevelAfterComment: number;
    }[] = [];

    for (const line of s.split('\n')) {
      let lastChunk: { commentType: CommentType; content: string } | undefined =
        chunksToReflow[chunksToReflow.length - 1];
      const trimmedLine = line.trim();

      // See what comment type they are using.

      let commentType: CommentType | undefined;

      for (const type of ActionVisualReflowParagraph.CommentTypes) {
        if (trimmedLine.startsWith(type.start)) {
          commentType = type;

          break;
        }

        // If they're currently in a multiline comment, see if they continued it.
        if (lastChunk && type.start === lastChunk.commentType.start && !type.singleLine) {
          if (trimmedLine.startsWith(type.inner)) {
            commentType = type;

            break;
          }

          if (trimmedLine.endsWith(type.final)) {
            commentType = type;

            break;
          }
        }
      }

      if (!commentType) {
        break;
      } // will never happen, just to satisfy typechecker.

      // Did they start a new comment type?
      if (!lastChunk || commentType.start !== lastChunk.commentType.start) {
        let chunk = {
          commentType,
          content: `${trimmedLine.substr(commentType.start.length).trim()}`,
          indentLevelAfterComment: 0,
        };
        if (commentType.singleLine) {
          chunk.indentLevelAfterComment =
            trimmedLine.substr(commentType.start.length).length - chunk.content.length;
        }
        chunksToReflow.push(chunk);

        continue;
      }

      // Parse out commenting style, gather words.

      lastChunk = chunksToReflow[chunksToReflow.length - 1];

      if (lastChunk.commentType.singleLine) {
        // is it a continuation of a comment like "//"
        lastChunk.content += `\n${trimmedLine.substr(lastChunk.commentType.start.length).trim()}`;
      } else {
        // are we in the middle of a multiline comment like "/*"
        if (trimmedLine.endsWith(lastChunk.commentType.final)) {
          if (trimmedLine.length > lastChunk.commentType.final.length) {
            lastChunk.content += `\n${trimmedLine
              .substr(
                lastChunk.commentType.inner.length,
                trimmedLine.length - lastChunk.commentType.final.length
              )
              .trim()}`;
          }
        } else if (trimmedLine.startsWith(lastChunk.commentType.inner)) {
          lastChunk.content += `\n${trimmedLine.substr(lastChunk.commentType.inner.length).trim()}`;
        } else if (trimmedLine.startsWith(lastChunk.commentType.start)) {
          lastChunk.content += `\n${trimmedLine.substr(lastChunk.commentType.start.length).trim()}`;
        }
      }
    }

    // Reflow each chunk.
    let result: string[] = [];

    for (const { commentType, content, indentLevelAfterComment } of chunksToReflow) {
      let lines: string[];
      const indentAfterComment = Array(indentLevelAfterComment + 1).join(' ');

      if (commentType.singleLine) {
        lines = [``];
      } else {
        lines = [``, ``];
      }

      // This tracks if we're pushing the first line of a chunk. If so, then we
      // don't want to add an extra space. In addition, when there's a blank
      // line, this needs to be reset.
      let curIndex = 0;
      for (const line of content.trim().split('\n')) {
        // Preserve newlines.

        if (line.trim() === '') {
          for (let i = 0; i < 2; i++) {
            lines.push(``);
          }
          curIndex = 0;

          continue;
        }

        // Add word by word, wrapping when necessary.
        const words = line.split(/\s+/);
        for (let i = 0; i < words.length; i++) {
          const word = words[i];
          if (word === '') {
            continue;
          }

          if (lines[lines.length - 1].length + word.length + 1 < maximumLineLength) {
            if (curIndex === 0 && i === 0) {
              lines[lines.length - 1] += `${word}`;
            } else {
              lines[lines.length - 1] += ` ${word}`;
            }
          } else {
            lines.push(`${word}`);
          }
        }
        curIndex++;
      }

      if (!commentType.singleLine) {
        lines.push(``);
      }

      if (commentType.singleLine) {
        if (lines.length > 1 && lines[0].trim() === '') {
          lines = lines.slice(1);
        }
        if (lines.length > 1 && lines[lines.length - 1].trim() === '') {
          lines = lines.slice(0, -1);
        }
      }

      for (let i = 0; i < lines.length; i++) {
        if (commentType.singleLine) {
          lines[i] = `${indent}${commentType.start}${indentAfterComment}${lines[i]}`;
        } else {
          if (i === 0) {
            lines[i] = `${indent}${commentType.start} ${lines[i]}`;
          } else if (i === lines.length - 1) {
            lines[i] = `${indent} ${commentType.final}`;
          } else {
            lines[i] = `${indent} ${commentType.inner} ${lines[i]}`;
          }
        }
      }

      result = result.concat(lines);
    }

    // Gather up multiple empty lines into single empty lines.
    return result.join('\n');
    */
